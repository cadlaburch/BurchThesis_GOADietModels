binnedplot(fitted(mod1),residuals(mod1))
library(generalhoslem)
library(arm)
library(faraway)
##DIAGNOSTICS
#check binned residuals
binnedplot(fitted(mod1),residuals(mod1))
binnedplot(fitted(Euph_M),residuals(Euph_M))
#check the hosmer lemeshow
logitgof(turtles$hatched,fitted(mod1))
halfnorm(hats <- hatvalues(Euph_M))
halfnorm(hats <- hatvalues(Euph_M))
#hatvalues
halfnorm(hats <- hatvalues(mod1))
#A: Build model crossed random effects of site and year.
mmod <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#Parameter estimates
sumary(mmod)
#fit a model with a slope and crossed random effects of region and (residual) year effects
#note that year is assumed to be a categorical variable when put into the RE
mmod1 <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = TRUE)
sumary(mmod1)
#Generate Kery's wallcreeper data with a trend in density in 12 different regions over 16 years, plus an additional year effect
set.seed(10)
yr <- 16
rgn <- 12 #number of regions
b0 <- 30 #overall intercept (mean)
b <- -0.8 #overall slope
sigma.regions <- 0.5 #SD of region-specific intercept effects
sigma.year <- 2 #SD of region-specific slope effects
sigma <- 2 #SD residual
#going to treat year as both a fixed and random effect
#simulating data (alphas)
rgn.int <- rnorm(rgn,0,sigma.regions) #generate deviates
yr.int <- rnorm(yr,0,sigma.year) #generate deviates
#true model has a single year slope, an additional year effect, and an effect of region
KW.slope1 <- matrix(NA,nrow = (rgn*yr),ncol = 3) #region #year #prcnt_occupied
count <- 1
for(i in 1:rgn){
for(j in 1:yr){
KW.slope1[count,1] <- i
KW.slope1[count,2] <- j
KW.slope1[count,3] <- round(b0 + rgn.int[i] + b*j + yr.int[j] + rnorm(1,0,sigma),dig=2)
count <- count + 1
}
}
KW.slope1 <- as.data.frame(KW.slope1)
colnames(KW.slope1) <- c("region","year","prcnt")
write.csv(KW.slope1,"KW.csv",row.names=FALSE)
rm(list=ls(all=TRUE))
KW.slope1 <- read.csv("KW.csv")
head(KW.slope1, n = 20)
##############################################################
#WRT REML vs ML
#We use REML=TRUE when testing two different (nested) random effects models (and it is preferred)
#We use REML=FALSE (i.e., ML) when testing a random effects model against a model without the random effect
#We use REML=FALSE (i.e., ML) to test (and calculate AIC etc) for fixed effects
#When we've run something with REML we can use exactRLRT for a LRT
#When we've run something with ML we can use exactLRT for a LRT
##############################################################
#fit a model with a slope and crossed random effects of region and (residual) year effects
#note that year is assumed to be a categorical variable when put into the RE
mmod1 <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = TRUE)
sumary(mmod1)
ranef(mmod1) #looking at deviation of random effects from B0
#Parameter estimates
sumary(mmod)
#A: Build model crossed random effects of site and year.
mmod <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#Parameter estimates
sumary(mmod)
#Load Data
HW3_morels <- read.csv("~/Documents/SMEA/Year 2/GLMModeling/homeworkl/HW3_morels.csv")
#A: Build model crossed random effects of site and year.
mmod <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#Parameter estimates
sumary(mmod)
#A: Build model crossed random effects of site and year.
mmodA <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#A: Build model crossed random effects of site and year.
mmod <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#--------------
#B: Test Random Effects
mmodS <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = T)
mmodY <- lmer(lambda ~ rain + (1|year), HW3_morels, REML = T)
#testing site RE
exactRLRT(mmodY,mmod,mmodS)
library(readr)
library(lme4)
library(faraway)
library(RLRsim)
#testing site RE
exactRLRT(mmodY,mmod,mmodS)
#testing year RE
exactRLRT(mmodS,mmod,mmodY)
#A: Build model crossed random effects of site and year.
mmod <- lmer(lambda ~ rain + (1|site) + (1|year), HW3_morels, REML = T)
#--------------
#B: Test Random Effects
mmodS <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = T)
mmodY <- lmer(lambda ~ rain + (1|year), HW3_morels, REML = T)
#testing site RE
exactRLRT(mmodY,mmod,mmodS) #p = 0.124
#testing site RE
exactRLRT(mmodY,mmod,mmodS) #p = 0.127
#testing year RE
exactRLRT(mmodS,mmod,mmodY) #p =
#Note that: exactRLRT(m.randA,m.randAB,m.randB) tests AB against B, but A is needed for the test to work
#use exactRLRT to evaluate the random effects
#low p value reject null model ()
#test of the year effect
exactRLRT(mmod3,mmod1,mmod2) # year, year + region, region (tests year + region against region, p value says year + region is better)
#fit a model with random effect of region only
mmod2 <- lmer(prcnt ~ year + (1|region), KW.slope1, REML = TRUE)
#fit a model with random effect of year only
mmod3 <- lmer(prcnt ~ year + (1|year), KW.slope1, REML = TRUE)
#fit a model with a slope and crossed random effects of region and (residual) year effects
#note that year is assumed to be a categorical variable when put into the RE
mmod1 <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = TRUE)
#Note that: exactRLRT(m.randA,m.randAB,m.randB) tests AB against B, but A is needed for the test to work
#use exactRLRT to evaluate the random effects
#low p value reject null model ()
#test of the year effect
exactRLRT(mmod3,mmod1,mmod2) # year, year + region, region (tests year + region against region, p value says year + region is better)
#now test a model with just the site or just the year effect against a model with neither
#note, here you will use exactLRT and be sure to specify REML = FALSE
mmodSF <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F)
mmodYF <- lmer(lambda ~ rain + (1|year), HW3_morels, REML = F)
mmodB <- lm(lambda ~ rain, HW3_morels)
#testing site
exactLRT(mmodSF,mmod) # region, null - tests region
#testing site
exactLRT(mmodSF,mmodB) # region, null - tests region
#testing year
exactLRT(mmodYF,mmodB) # year, null - tests year
??exactLRT
#testing site
exactLRT(mmodSF,mmodB) # p < 2.2 e-16
mmod1.f <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F)
mmod2.f <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F)
extractAIC(mmod1.f)
extractAIC(mmod2.f)
summary(mmod1.f <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = FALSE) )
summary(mmod5.f <- lmer(prcnt ~ 1 + (1|region) + (1|year), KW.slope1, REML = FALSE) )
extractAIC(mmod1.f)
extractAIC(mmod5.f)
summary(mmod1.f <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F))
summary(mmod2.f <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F))
extractAIC(mmod1.f)
extractAIC(mmod2.f)
summary(mmod1.f <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F))
summary(mmod2.f <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F))
extractAIC(mmod1.f)
extractAIC(mmod2.f)
#Parameter estimates
sumary(mmodA)
??lmer
#---------------
#F: Bootstrapped confidence intervals
bestmod <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = T)
confint(bestmod,method = "boot")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(lme4)
library(RLRsim)
library(faraway)
#generate a dataset with nested and crossed random effects
#individual is nested within colony, crossed with a day effect
n <- 312
b0 <- 2
b1 <- 1.2
sigma.ind <- 0.1
sigma.day <- 0.1
sigma.colony <- 0.4
sigma.error <- 0.2
set.seed(6)
day <- sort(sample(1:10, n, replace = TRUE)) #we sample on 10 days
ind <- NA
for(d in 1:10){
temp <- sample(1:42,length(which(day == d))) #each day we sample some number of our 42 individuals
ind <- c(ind,temp)
}
ind <- ind[-1]
colony <- NA #there will be 6 colonies, 7 ind per colony
for(i in 1:7){
colony[which(ind == (i-1)*7+1 | ind == (i-1)*7+2 | ind == (i-1)*7+3 | ind == (i-1)*7+4 | ind == (i-1)*7+5 | ind == (i-1)*7+6 | ind == (i-1)*7+7)] <- i
}
indcol <- rep(NA,n)
for(i in 1:n){
if(is.element(ind[i],c(1,8,15,22,29,36))==TRUE){indcol[i] <- 1}
if(is.element(ind[i],c(2,9,16,23,30,37))==TRUE){indcol[i] <- 2}
if(is.element(ind[i],c(3,10,17,24,31,38))==TRUE){indcol[i] <- 3}
if(is.element(ind[i],c(4,11,18,25,32,39))==TRUE){indcol[i] <- 4}
if(is.element(ind[i],c(5,12,19,26,33,40))==TRUE){indcol[i] <- 5}
if(is.element(ind[i],c(6,13,20,27,34,41))==TRUE){indcol[i] <- 6}
if(is.element(ind[i],c(7,14,21,28,35,42))==TRUE){indcol[i] <- 7}
}
ambient <- NA
for(i in 1:6){
for(j in 1:10){
ambient[intersect(which(colony == i),which(day == j))] <- round(runif(1,-3,10),dig=2)
}
}
bat.data <- data.frame(cbind(day,ambient,colony,ind,indcol ))
bat.data <- bat.data[order(day, colony, indcol),]
bat.data$s.ambient <- (bat.data$ambient - mean(bat.data$ambient))/sd(bat.data$ambient)
dev.ind <- rnorm(42,0,sigma.ind)
dev.col <- rnorm(6,0,sigma.colony)
dev.day <- rnorm(10,0,sigma.day)
for(i in 1:n){
bat.data$temp[i] <- round(b0 + b1*bat.data$ambient[i] + dev.ind[bat.data$ind[i]] + dev.col[bat.data$col[i]] + dev.day[bat.data$day[i]] + rnorm(1,0,sigma.error),3)
}
bat.data.out <- bat.data[,-c(4,6)]
bat.data.out$individual.colony <- as.factor(as.character(paste(bat.data.out$col,bat.data.out$ind,sep="")))
colnames(bat.data.out) <- c("day","ambient","colony","ind.col","bat.temp","ind")
col_order <- c("day", "ambient", "colony",
"ind.col", "ind","bat.temp")
bat.data <- bat.data.out[, col_order]
write.csv(bat.data,"bats.csv",row.names=FALSE)
rm(list=ls(all=TRUE))
bat.data <- read.csv("bats.csv")
head(bat.data,n = 10)
#fit global model - with this syntax for nesting, order doesn't matter
lmod1 <- lmer(bat.temp ~ ambient + (1|day) + (1|colony) + (1|colony:ind.col), bat.data,REML=TRUE)
#notice that this is equivalent except that with this syntax for nesting, order does matter - this is equivalent to above, with a main effect of colony
lmod1.alt <- lmer(bat.temp ~ ambient + (1|day) + (1|colony/ind.col), bat.data,REML=TRUE)
sumary(lmod1)
sumary(lmod1.alt)
#does this have the same residual?
lmod1a <- lmer(bat.temp ~ ambient + (1|day) + (1|ind), bat.data)
sumary(lmod1a)
#parametric bootstrap to test random effect of day
lmod1 <- lmer(bat.temp ~ ambient + (1|day) + (1|colony) + (1|colony:ind.col), bat.data)
lmod2 <- lmer(bat.temp ~ ambient + (1|colony) + (1|colony:ind.col), bat.data)
lrstat <- 2*(logLik(lmod1)-logLik(lmod2))
b.lrstat <- numeric(100)
set.seed(123)
for(i in 1:100){
y <- unlist(simulate(lmod2))
bnull <- lmer(y ~ ambient + (1|colony) + (1|colony:ind.col), bat.data,control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-4)))
balt <- lmer(y ~ ambient + (1|day) + (1|colony) + (1|colony:ind.col), bat.data,control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-4)))
b.lrstat[i] <- as.numeric(2*(logLik(balt)-logLik(bnull)))
}
(p <- mean(b.lrstat > lrstat)  )
#now with exactRLRT
lmodtest <- lmer(bat.temp ~ ambient + (1|day),bat.data)
#test of the day effect - equivalent to above
exactRLRT(lmodtest,lmod1,lmod2)
#evaluate fixed effect with AIC
lmod.ML1 <- lmer(bat.temp ~ ambient + (1|day) + (1|colony) + (1|colony:ind.col), bat.data, REML = FALSE)
lmod.MLn <- lmer(bat.temp ~ 1 + (1|day) + (1|colony) + (1|colony:ind.col), bat.data, REML = FALSE)
extractAIC(lmod.ML1)
extractAIC(lmod.MLn)
#6. bootstrap CIs using the manual boostrap
bsd <- matrix(NA,nrow = 100, ncol = 5)
for(i in 1:100){
y <- unlist(simulate(lmod1))
bmod <- lmer(y ~ ambient + (1|day) + (1|colony) + (1|colony:ind.col), bat.data,REML=TRUE, control=lmerControl(check.conv.singular = .makeCC(action = "ignore",  tol = 1e-4)))
bsd[i,1:3] <- as.data.frame(VarCorr(bmod))$sdcor[1:3]
bsd[i,4] <- summary(bmod)$coefficients[1,1]
bsd[i,5] <- summary(bmod)$coefficients[2,1]
}
quantile(bsd[,1],probs=c(0.025,0.975))
quantile(bsd[,2],probs=c(0.025,0.975))
quantile(bsd[,3],probs=c(0.025,0.975))
quantile(bsd[,4],probs=c(0.025,0.975))
quantile(bsd[,5],probs=c(0.025,0.975))
#bootstrap CIs using the confint() method
confint(lmod1,method = "boot")
bsd
quantile(bsd[,1],probs=c(0.025,0.975))
quantile(bsd[,2],probs=c(0.025,0.975))
quantile(bsd[,3],probs=c(0.025,0.975))
quantile(bsd[,4],probs=c(0.025,0.975))
quantile(bsd[,5],probs=c(0.025,0.975))
bestmod <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = T)
#Load Data
HW3_morels <- read.csv("~/Documents/SMEA/Year 2/GLMModeling/homeworkl/HW3_morels.csv")
#---------------
#F: Bootstrapped confidence intervals
bestmod <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = T)
confint(bestmod,method = "boot")
??confint
#fit a model with a slope and crossed random effects of region and (residual) year effects
#note that year is assumed to be a categorical variable when put into the RE
mmod1 <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = TRUE)
KW.slope1 <- read.csv("KW.csv")
#fit a model with crossed random effects of region and year with ML instead of REML
mmod1.ML <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = FALSE)
#get confidence intervals
#this provides CIs on SDs
confint(mmod1, method = "boot")  #64/1000 times it failed but thats ok
#fit a model with a slope and crossed random effects of region and (residual) year effects
#note that year is assumed to be a categorical variable when put into the RE
mmod1 <- lmer(prcnt ~ year + (1|region) + (1|year), KW.slope1, REML = TRUE)
#get confidence intervals
#this provides CIs on SDs
confint(mmod1, method = "boot")  #64/1000 times it failed but thats ok
summarize(bestmod)
sumary(bestmod)
confint(bestmod,method = "boot", oldNames = F)
mod1 <- glm(hatched ~ depth, turtles, family = "binomial")
n <- 782
turtles <- matrix(NA,nrow = n, ncol = 3)
set.seed(6)
turtles[,1] <- sample(1:28,n, replace = TRUE)
turtles[,2] <- scale(round(runif(n,5,80),dig=0))
b0 <- -0.8
b1 <- 1.5
p <- 1/(1+exp(-(b0 + b1*turtles[,2])))
turtles[,3] <- rbinom(n,1,p)
turtles <- turtles[order(turtles[,1]),]
colnames(turtles) <- c("nest","depth","hatched")
turtles <- as.data.frame(turtles)
mod1 <- glm(hatched ~ depth, turtles, family = "binomial")
mod2 <- glm(hatched ~ 1, turtles, family = "binomial")
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab [1,2] <- summary(mod1)$deviance + 2*2
AIC.tab [2,2] <- summary(mod2)$deviance + 2*1
AIC.tab [,3] <- AIC.tab[,2] - min(AIC.tab[,2])
AIC.tab [,4] <- exp(-0.5*AIC.tab[,3]) / sum(exp(-0.5*AIC.tab[,3]))
AIC.tab [,1] <- c("depth","null")
colnames(AIC.tab) <- c("Model","AIC","dAIC","Akaike weight")
View(AIC.tab)
mod1AIC <- extractAIC(mmod1.f) #AIC = -1491.642
mod2AIC <- extractAIC(mmod2.f) #AIC = -971.6425
summary(mmod1.f <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F))
summary(mmod2.f <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F))
mod1AIC <- extractAIC(mmod1.f) #AIC = -1491.642
mod2AIC <- extractAIC(mmod2.f) #AIC = -971.6425
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab[,1] <-t(cbind(mod1AIC, mod2AIC))
AIC.tab <- matrix(NA,nrow=2,ncol=4)
AIC.tab[,1] <-t(cbind(mod1AIC, mod2AIC))
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab [1,2] <- extractAIC(mmod1.f)
AIC.tab [1,2] <- summary(mod1)$deviance + 2*2
mod1 <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F)
mod2 <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F)
AIC.tab [1,2] <- summary(mod1)$deviance + 2*2
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab [1,2] <- summary(mod1)$deviance + 2*2
AIC.tab [1,2] <- -1491.642
AIC.tab [2,2] <- -971.6425
AIC.tab [,3] <- AIC.tab[,2] - min(AIC.tab[,2])
AIC.tab [,4] <- exp(-0.5*AIC.tab[,3]) / sum(exp(-0.5*AIC.tab[,3]))
AIC.tab [,1] <- c("REmodel","null")
colnames(AIC.tab) <- c("Model","AIC","dAIC","Akaike weight")
MA.predict <- predict(mod1)*AIC.tab[1,3] + predict(mod2)*AIC.tab[2,3]
MA.predict
#---------------
#E
plot(MA.predict)
#---------------
#E
plot(MA.predict, HW3_morels$rain)
#---------------
#E
plot(HW3_morels$rain, MA.predict)
#GENERATE DATA
#generate a data set with a Bernoulli random variables
#snapping turtle egg hatching success in 28 nests, as a function of egg depth
n <- 782
turtles <- matrix(NA,nrow = n, ncol = 3)
set.seed(6)
turtles[,1] <- sample(1:28,n, replace = TRUE)
turtles[,2] <- scale(round(runif(n,5,80),dig=0))
b0 <- -0.8
b1 <- 1.5
p <- 1/(1+exp(-(b0 + b1*turtles[,2])))
turtles[,3] <- rbinom(n,1,p)
turtles <- turtles[order(turtles[,1]),]
colnames(turtles) <- c("nest","depth","hatched")
turtles <- as.data.frame(turtles)
##MODEL
mod1 <- glm(hatched ~ depth, turtles, family = "binomial")
summary(mod1)
##DIAGNOSTICS
#check binned residuals
binnedplot(fitted(mod1),residuals(mod1))
#check the hosmer lemeshow
logitgof(turtles$hatched,fitted(mod1))
#hatvalues
halfnorm(hats <- hatvalues(mod1))
#cooks
halfnorm(cooks <- cooks.distance(mod1))
##MODEL SELECTION
mod1 <- glm(hatched ~ depth, turtles, family = "binomial")
mod2 <- glm(hatched ~ 1, turtles, family = "binomial")
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab [1,2] <- summary(mod1)$deviance + 2*2
AIC.tab [2,2] <- summary(mod2)$deviance + 2*1
AIC.tab [,3] <- AIC.tab[,2] - min(AIC.tab[,2])
AIC.tab [,4] <- exp(-0.5*AIC.tab[,3]) / sum(exp(-0.5*AIC.tab[,3]))
AIC.tab [,1] <- c("depth","null")
colnames(AIC.tab) <- c("Model","AIC","dAIC","Akaike weight")
#PREDICT
#one way to get uncertainty on the real scale is with a bootstrap
depth.new <- seq(from = min(turtles$depth),max(turtles$depth),0.1)
newData1 <- data.frame(depth = depth.new)
summ.best <- matrix(NA,nrow = nrow(newData1), ncol=4)
boots <- 100
yest <- matrix(NA,nrow=nrow(newData1),ncol=boots)
for(i in 1:boots){
y <- unlist(simulate(mod1))
ymod <- glm(y ~ depth, turtles, family = "binomial")
yest[,i] <- predict(ymod,newdata = newData1, type="response")
}
for(i in 1:nrow(newData1)){
summ.best[i,1] <- mean(yest[i,])
summ.best[i,2] <- quantile(yest[i,],probs=0.025)
summ.best[i,3] <- quantile(yest[i,],probs=0.975)
summ.best[i,4] <- sd(yest[i,])
}
#PLOT
par(mai = c(1,1,0.5,0.5))
plot(depth.new, summ.best[,1],type = "l",ylab = "Hatched",xlab = "Depth",cex.lab = 1.5, cex.axis=1.5,ylim=c(0,1))
lines(depth.new, summ.best[,2],lty= 2)
lines(depth.new, summ.best[,3],lty= 2)
#---------------
#E
plot(HW3_morels$rain, HW3_morels$lambda)
plot(MA.predict, add = T)
#PLOT
par(mai = c(1,1,0.5,0.5))
plot(depth.new, summ.best[,1],type = "l",ylab = "Hatched",xlab = "Depth",cex.lab = 1.5, cex.axis=1.5,ylim=c(0,1))
lines(depth.new, summ.best[,2],lty= 2)
lines(depth.new, summ.best[,3],lty= 2)
#PLOT model 1 for 3 regions only
#plot all data
plot(KW.slope1$year,KW.slope1$prcnt,xlab = "Year",ylab = "Percent Occupied")
newdata <- with(KW.slope1, expand.grid(year=c(17,18)))
levs <- nrow(newdata)
?predict.merMod #Will default to this function when you have random effects in the model
year.sd <- as.data.frame(VarCorr(mmod1))$sdcor[1]
region.sd <- as.data.frame(VarCorr(mmod1))$sdcor[2]
resid.sd <- as.data.frame(VarCorr(mmod1))$sdcor[3]
pv <- matrix(NA,nrow=100,ncol = levs)
for(i in 1:100){
#we simulate conditioning on no specific random effects levels
y <- unlist(simulate(mmod1))
bmod <- refit(mmod1,y)
#re.form(formula, NULL, or NA) specify which random effects to condition on when predicting. If NULL, include all random effects; if NA or ~0, include no random effects
# ~0 indicates we are not conditioning on the specific REs observed (i.e., we have a new site and year)
pv[i,] <- predict(bmod, re.form = ~0, newdata) + rnorm(1,0,sd=year.sd) + rnorm(1,0,sd=region.sd) + rnorm(1,0,sd=resid.sd)
}  #asking to predict using the model equation and then adding back in varience due to random effects and residuals
plot(x = unlist(newdata), y = apply(pv, 2, mean), xlab = "Year", ylab = "Percent", ylim = c(0,20))
lines(x = unlist(newdata), y = apply(pv, 2, quantile, probs=c(0.025)) )
lines(x = unlist(newdata), y = apply(pv, 2, quantile, probs=c(0.975)) )
#---------------
#E
plot(HW3_morels$rain, HW3_morels$lambda)
plot(HW3_morels$rain, MA.predict, add = T)
plot(c(1:30),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0,140))
length(MA.predict)
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0,140))
range(MA.predict)
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(400,550))
mod1 <- lmer(lambda ~ rain + (1|site), HW3_morels, REML = F)
mod2 <- lmer(lambda ~ 1 + (1|site), HW3_morels, REML = F)
points(c(1:900),predict(mod1),col = "blue")
points(c(1:900),predict(mod2),col = "red")
AIC.tab[1,3]
AIC.tab <- data.frame(NA,nrow=2,ncol=4)
AIC.tab [1,2] <- -1491.642
AIC.tab [2,2] <- -971.6425
AIC.tab [,3] <- AIC.tab[,2] - min(AIC.tab[,2])
AIC.tab [,4] <- exp(-0.5*AIC.tab[,3]) / sum(exp(-0.5*AIC.tab[,3]))
AIC.tab [,1] <- c("REmodel","null")
colnames(AIC.tab) <- c("Model","AIC","dAIC","Akaike weight")
AIC.tab[1,3]
AIC.tab[2,3]
MA.predict <- predict(mod1)*AIC.tab[2,3] + predict(mod2)*AIC.tab[3,3]
length(MA.predict)
range(MA.predict)
AIC.tab[3,3]
AIC.tab[3,3]
MA.predict <- predict(mod1)*AIC.tab[2,4] + predict(mod2)*AIC.tab[3,4]
length(MA.predict)
range(MA.predict)
AIC.tab[2,4]
AIC.tab[3,4]
AIC.tab
AIC.tab[1,4]
AIC.tab[2,4]
MA.predict <- predict(mod1)*AIC.tab[1,4] + predict(mod2)*AIC.tab[2,4]
length(MA.predict)
range(MA.predict)
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(400,550))
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2))
points(c(1:900),predict(mod1),col = "blue")
points(c(1:900),predict(mod2),col = "red")
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2))
points(c(1:900),predict(mod1),col = "blue", size = 1)
points(c(1:900),predict(mod1),col = "blue", size = .1)
?points
points(c(1:900),predict(mod1),col = "blue", pch = 20)
points(c(1:900),predict(mod2),col = "red", pch = 20)
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2), pch = 20)
points(c(1:900),predict(mod1),col = "blue", pch = 20)
points(c(1:900),predict(mod1),col = "blue", pch = 20, alpha = 0.5)
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2), pch = 20)
points(c(1:900),predict(mod1),col = "blue", pch = 20)
points(c(1:900),predict(mod2),col = "red", pch = 20)
MA.predict
axis(side = 1, labels = rownames(gala),at = c(1:30))
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2), pch = 20)
axis(side = 1, labels = rownames(gala),at = c(1:30))
plot(c(1:900),MA.predict,xaxt="n",xlab = "Rain",ylab = "Lambda",ylim = c(0, 2), pch = 20)
plot(c(1:900),MA.predict,xlab = "Rain",ylab = "Lambda",ylim = c(0, 2), pch = 20)
points(c(1:900),predict(mod1),col = "blue", pch = 20)
points(c(1:900),predict(mod2),col = "red", pch = 20)
legend(1,1.9,c("Model-averaged","RE Model","Model 2"),col =c( "black", "blue", "red"),pch = c(1,1,1))
